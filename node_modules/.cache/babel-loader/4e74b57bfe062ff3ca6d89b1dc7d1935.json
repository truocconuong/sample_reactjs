{"ast":null,"code":"import { __assign, __read, __spread } from \"tslib\";\nimport { useMemo } from 'react';\nimport { useAnalyticsEvents } from './useAnalyticsEvents';\nexport function usePatchedProps(createEventMap, wrappedComponentProps) {\n  if (createEventMap === void 0) {\n    createEventMap = {};\n  }\n\n  var createAnalyticsEvent = useAnalyticsEvents().createAnalyticsEvent;\n  var patchedProps = useMemo(function () {\n    return Object.keys(createEventMap).reduce(function (p, k) {\n      var _a;\n\n      var eventCreator = createEventMap[k];\n\n      if (!['object', 'function'].includes(typeof eventCreator)) {\n        return p;\n      }\n\n      var propValue = wrappedComponentProps[k];\n\n      var wrappedCallback = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var analyticsEvent = typeof eventCreator === 'function' ? eventCreator(createAnalyticsEvent, wrappedComponentProps) : createAnalyticsEvent(eventCreator);\n\n        if (propValue && typeof propValue === 'function') {\n          propValue.apply(void 0, __spread(args, [analyticsEvent]));\n        }\n      };\n\n      return wrappedCallback ? __assign(__assign({}, p), (_a = {}, _a[k] = wrappedCallback, _a)) : p;\n    }, {});\n  }, [createEventMap, wrappedComponentProps, createAnalyticsEvent]);\n  return {\n    patchedEventProps: patchedProps\n  };\n}","map":{"version":3,"sources":["../../../src/hooks/usePatchedProps.ts"],"names":[],"mappings":";AAAA,SAAS,OAAT,QAAwB,OAAxB;AAIA,SAAS,kBAAT,QAAmC,sBAAnC;AAMA,OAAM,SAAU,eAAV,CACJ,cADI,EAEJ,qBAFI,EAEwB;AAD5B,MAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,cAAA,GAAA,EAAA;AAAmC;;AAG3B,MAAA,oBAAoB,GAAK,kBAAkB,GAAvB,oBAApB;AAER,MAAM,YAAY,GAAG,OAAO,CAAC,YAAA;AAC3B,WAAO,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,MAA5B,CAA0C,UAAC,CAAD,EAAI,CAAJ,EAAK;;;AACpD,UAAM,YAAY,GAAG,cAAc,CAAC,CAAD,CAAnC;;AACA,UAAI,CAAC,CAAC,QAAD,EAAW,UAAX,EAAuB,QAAvB,CAAgC,OAAO,YAAvC,CAAL,EAA2D;AACzD,eAAO,CAAP;AACD;;AAED,UAAM,SAAS,GAAG,qBAAqB,CAAC,CAAD,CAAvC;;AAEA,UAAM,eAAe,GAAG,YAAA;AAAC,YAAA,IAAA,GAAA,EAAA;;aAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,UAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACvB,YAAM,cAAc,GAClB,OAAO,YAAP,KAAwB,UAAxB,GACK,YAAsC,CACrC,oBADqC,EAErC,qBAFqC,CAD3C,GAKI,oBAAoB,CAAC,YAAD,CAN1B;;AAQA,YAAI,SAAS,IAAI,OAAO,SAAP,KAAqB,UAAtC,EAAkD;AAChD,UAAA,SAAS,CAAA,KAAT,CAAS,KAAA,CAAT,EAAS,QAAA,CAAI,IAAJ,EAAQ,CAAE,cAAF,CAAR,CAAT;AACD;AACF,OAZD;;AAaA,aAAO,eAAe,GAAE,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,CAAN,CAAA,GAAO,EAAA,GAAA,EAAA,EAAA,EAAA,CAAG,CAAH,CAAA,GAAO,eAAP,EAAsB,EAA7B,EAAF,GAAoC,CAA1D;AACD,KAtBM,EAsBJ,EAtBI,CAAP;AAuBD,GAxB2B,EAwBzB,CAAC,cAAD,EAAiB,qBAAjB,EAAwC,oBAAxC,CAxByB,CAA5B;AA0BA,SAAO;AACL,IAAA,iBAAiB,EAAE;AADd,GAAP;AAGD","sourceRoot":"","sourcesContent":["import { __assign, __read, __spread } from \"tslib\";\nimport { useMemo } from 'react';\nimport { useAnalyticsEvents } from './useAnalyticsEvents';\nexport function usePatchedProps(createEventMap, wrappedComponentProps) {\n    if (createEventMap === void 0) { createEventMap = {}; }\n    var createAnalyticsEvent = useAnalyticsEvents().createAnalyticsEvent;\n    var patchedProps = useMemo(function () {\n        return Object.keys(createEventMap).reduce(function (p, k) {\n            var _a;\n            var eventCreator = createEventMap[k];\n            if (!['object', 'function'].includes(typeof eventCreator)) {\n                return p;\n            }\n            var propValue = wrappedComponentProps[k];\n            var wrappedCallback = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var analyticsEvent = typeof eventCreator === 'function'\n                    ? eventCreator(createAnalyticsEvent, wrappedComponentProps)\n                    : createAnalyticsEvent(eventCreator);\n                if (propValue && typeof propValue === 'function') {\n                    propValue.apply(void 0, __spread(args, [analyticsEvent]));\n                }\n            };\n            return wrappedCallback ? __assign(__assign({}, p), (_a = {}, _a[k] = wrappedCallback, _a)) : p;\n        }, {});\n    }, [createEventMap, wrappedComponentProps, createAnalyticsEvent]);\n    return {\n        patchedEventProps: patchedProps,\n    };\n}\n//# sourceMappingURL=usePatchedProps.js.map"]},"metadata":{},"sourceType":"module"}