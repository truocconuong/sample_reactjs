{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['react', 'prop-types', 'create-react-class'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('react'), require('prop-types'), require('create-react-class'));\n  } else {\n    root.ReactSlider = factory(root.React, root.PropTypes, root.createReactClass);\n  }\n})(this, function (React, PropTypes, createReactClass) {\n  /**\n   * To prevent text selection while dragging.\n   * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n   */\n  function pauseEvent(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    if (e.preventDefault) e.preventDefault();\n    return false;\n  }\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n  }\n  /**\n   * Spreads `count` values equally between `min` and `max`.\n   */\n\n\n  function linspace(min, max, count) {\n    var range = (max - min) / (count - 1);\n    var res = [];\n\n    for (var i = 0; i < count; i++) {\n      res.push(min + range * i);\n    }\n\n    return res;\n  }\n\n  function ensureArray(x) {\n    return x == null ? [] : Array.isArray(x) ? x : [x];\n  }\n\n  function undoEnsureArray(x) {\n    return x != null && x.length === 1 ? x[0] : x;\n  } // undoEnsureArray(ensureArray(x)) === x\n\n\n  var ReactSlider = createReactClass({\n    displayName: 'ReactSlider',\n    propTypes: {\n      /**\n       * The minimum value of the slider.\n       */\n      min: PropTypes.number,\n\n      /**\n       * The maximum value of the slider.\n       */\n      max: PropTypes.number,\n\n      /**\n       * Value to be added or subtracted on each step the slider makes.\n       * Must be greater than zero.\n       * `max - min` should be evenly divisible by the step value.\n       */\n      step: PropTypes.number,\n\n      /**\n       * The minimal distance between any pair of handles.\n       * Must be positive, but zero means they can sit on top of each other.\n       */\n      minDistance: PropTypes.number,\n\n      /**\n       * Determines the initial positions of the handles and the number of handles if the component has no children.\n       *\n       * If a number is passed a slider with one handle will be rendered.\n       * If an array is passed each value will determine the position of one handle.\n       * The values in the array must be sorted.\n       * If the component has children, the length of the array must match the number of children.\n       */\n      defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n      /**\n       * Like `defaultValue` but for [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n       */\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n      /**\n       * Determines whether the slider moves horizontally (from left to right) or vertically (from top to bottom).\n       */\n      orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n      /**\n       * The css class set on the slider node.\n       */\n      className: PropTypes.string,\n\n      /**\n       * The css class set on each handle node.\n       *\n       * In addition each handle will receive a numbered css class of the form `${handleClassName}-${i}`,\n       * e.g. `handle-0`, `handle-1`, ...\n       */\n      handleClassName: PropTypes.string,\n\n      /**\n       * The css class set on the handle that is currently being moved.\n       */\n      handleActiveClassName: PropTypes.string,\n\n      /**\n       * If `true` bars between the handles will be rendered.\n       */\n      withBars: PropTypes.bool,\n\n      /**\n       * The css class set on the bars between the handles.\n       * In addition bar fragment will receive a numbered css class of the form `${barClassName}-${i}`,\n       * e.g. `bar-0`, `bar-1`, ...\n       */\n      barClassName: PropTypes.string,\n\n      /**\n       * If `true` the active handle will push other handles\n       * within the constraints of `min`, `max`, `step` and `minDistance`.\n       */\n      pearling: PropTypes.bool,\n\n      /**\n       * If `true` the handles can't be moved.\n       */\n      disabled: PropTypes.bool,\n\n      /**\n       * Disables handle move when clicking the slider bar\n       */\n      snapDragDisabled: PropTypes.bool,\n\n      /**\n       * Inverts the slider.\n       */\n      invert: PropTypes.bool,\n\n      /**\n       * Callback called before starting to move a handle.\n       */\n      onBeforeChange: PropTypes.func,\n\n      /**\n       * Callback called on every value change.\n       */\n      onChange: PropTypes.func,\n\n      /**\n       * Callback called only after moving a handle has ended.\n       */\n      onAfterChange: PropTypes.func,\n\n      /**\n       *  Callback called when the the slider is clicked (handle or bars).\n       *  Receives the value at the clicked position as argument.\n       */\n      onSliderClick: PropTypes.func\n    },\n    getDefaultProps: function () {\n      return {\n        min: 0,\n        max: 100,\n        step: 1,\n        minDistance: 0,\n        defaultValue: 0,\n        orientation: 'horizontal',\n        className: 'slider',\n        handleClassName: 'handle',\n        handleActiveClassName: 'active',\n        barClassName: 'bar',\n        withBars: false,\n        pearling: false,\n        disabled: false,\n        snapDragDisabled: false,\n        invert: false\n      };\n    },\n    getInitialState: function () {\n      var value = this._or(ensureArray(this.props.value), ensureArray(this.props.defaultValue)); // reused throughout the component to store results of iterations over `value`\n\n\n      this.tempArray = value.slice(); // array for storing resize timeouts ids\n\n      this.pendingResizeTimeouts = [];\n      var zIndices = [];\n\n      for (var i = 0; i < value.length; i++) {\n        value[i] = this._trimAlignValue(value[i], this.props);\n        zIndices.push(i);\n      }\n\n      return {\n        index: -1,\n        upperBound: 0,\n        sliderLength: 0,\n        value: value,\n        zIndices: zIndices\n      };\n    },\n    // Keep the internal `value` consistent with an outside `value` if present.\n    // This basically allows the slider to be a controlled component.\n    componentWillReceiveProps: function (newProps) {\n      var value = this._or(ensureArray(newProps.value), this.state.value); // ensure the array keeps the same size as `value`\n\n\n      this.tempArray = value.slice();\n\n      for (var i = 0; i < value.length; i++) {\n        this.state.value[i] = this._trimAlignValue(value[i], newProps);\n      }\n\n      if (this.state.value.length > value.length) this.state.value.length = value.length; // If an upperBound has not yet been determined (due to the component being hidden\n      // during the mount event, or during the last resize), then calculate it now\n\n      if (this.state.upperBound === 0) {\n        this._handleResize();\n      }\n    },\n    // Check if the arity of `value` or `defaultValue` matches the number of children (= number of custom handles).\n    // If no custom handles are provided, just returns `value` if present and `defaultValue` otherwise.\n    // If custom handles are present but neither `value` nor `defaultValue` are applicable the handles are spread out\n    // equally.\n    // TODO: better name? better solution?\n    _or: function (value, defaultValue) {\n      var count = React.Children.count(this.props.children);\n\n      switch (count) {\n        case 0:\n          return value.length > 0 ? value : defaultValue;\n\n        case value.length:\n          return value;\n\n        case defaultValue.length:\n          return defaultValue;\n\n        default:\n          if (value.length !== count || defaultValue.length !== count) {\n            console.warn(this.constructor.displayName + \": Number of values does not match number of children.\");\n          }\n\n          return linspace(this.props.min, this.props.max, count);\n      }\n    },\n    componentDidMount: function () {\n      window.addEventListener('resize', this._handleResize);\n\n      this._handleResize();\n    },\n    componentWillUnmount: function () {\n      this._clearPendingResizeTimeouts();\n\n      window.removeEventListener('resize', this._handleResize);\n    },\n    getValue: function () {\n      return undoEnsureArray(this.state.value);\n    },\n    _handleResize: function () {\n      // setTimeout of 0 gives element enough time to have assumed its new size if it is being resized\n      var resizeTimeout = window.setTimeout(function () {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        this.pendingResizeTimeouts.shift();\n        var slider = this.refs.slider;\n        var handle = this.refs.handle0;\n        var rect = slider.getBoundingClientRect();\n\n        var size = this._sizeKey();\n\n        var sliderMax = rect[this._posMaxKey()];\n\n        var sliderMin = rect[this._posMinKey()];\n\n        this.setState({\n          upperBound: slider[size] - handle[size],\n          sliderLength: Math.abs(sliderMax - sliderMin),\n          handleSize: handle[size],\n          sliderStart: this.props.invert ? sliderMax : sliderMin\n        });\n      }.bind(this), 0);\n      this.pendingResizeTimeouts.push(resizeTimeout);\n    },\n    // clear all pending timeouts to avoid error messages after unmounting\n    _clearPendingResizeTimeouts: function () {\n      do {\n        var nextTimeout = this.pendingResizeTimeouts.shift();\n        clearTimeout(nextTimeout);\n      } while (this.pendingResizeTimeouts.length);\n    },\n    // calculates the offset of a handle in pixels based on its value.\n    _calcOffset: function (value) {\n      var range = this.props.max - this.props.min;\n\n      if (range === 0) {\n        return 0;\n      }\n\n      var ratio = (value - this.props.min) / range;\n      return ratio * this.state.upperBound;\n    },\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `_calcOffset`.\n    _calcValue: function (offset) {\n      var ratio = offset / this.state.upperBound;\n      return ratio * (this.props.max - this.props.min) + this.props.min;\n    },\n    _buildHandleStyle: function (offset, i) {\n      var style = {\n        position: 'absolute',\n        willChange: this.state.index >= 0 ? this._posMinKey() : '',\n        zIndex: this.state.zIndices.indexOf(i) + 1\n      };\n      style[this._posMinKey()] = offset + 'px';\n      return style;\n    },\n    _buildBarStyle: function (min, max) {\n      var obj = {\n        position: 'absolute',\n        willChange: this.state.index >= 0 ? this._posMinKey() + ',' + this._posMaxKey() : ''\n      };\n      obj[this._posMinKey()] = min;\n      obj[this._posMaxKey()] = max;\n      return obj;\n    },\n    _getClosestIndex: function (pixelOffset) {\n      var minDist = Number.MAX_VALUE;\n      var closestIndex = -1;\n      var value = this.state.value;\n      var l = value.length;\n\n      for (var i = 0; i < l; i++) {\n        var offset = this._calcOffset(value[i]);\n\n        var dist = Math.abs(pixelOffset - offset);\n\n        if (dist < minDist) {\n          minDist = dist;\n          closestIndex = i;\n        }\n      }\n\n      return closestIndex;\n    },\n    _calcOffsetFromPosition: function (position) {\n      var pixelOffset = position - this.state.sliderStart;\n      if (this.props.invert) pixelOffset = this.state.sliderLength - pixelOffset;\n      pixelOffset -= this.state.handleSize / 2;\n      return pixelOffset;\n    },\n    // Snaps the nearest handle to the value corresponding to `position` and calls `callback` with that handle's index.\n    _forceValueFromPosition: function (position, callback) {\n      var pixelOffset = this._calcOffsetFromPosition(position);\n\n      var closestIndex = this._getClosestIndex(pixelOffset);\n\n      var nextValue = this._trimAlignValue(this._calcValue(pixelOffset));\n\n      var value = this.state.value.slice(); // Clone this.state.value since we'll modify it temporarily\n\n      value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n      for (var i = 0; i < value.length - 1; i += 1) {\n        if (value[i + 1] - value[i] < this.props.minDistance) return;\n      }\n\n      this.setState({\n        value: value\n      }, callback.bind(this, closestIndex));\n    },\n    _getMousePosition: function (e) {\n      return [e['page' + this._axisKey()], e['page' + this._orthogonalAxisKey()]];\n    },\n    _getTouchPosition: function (e) {\n      var touch = e.touches[0];\n      return [touch['page' + this._axisKey()], touch['page' + this._orthogonalAxisKey()]];\n    },\n    _getKeyDownEventMap: function () {\n      return {\n        'keydown': this._onKeyDown,\n        'focusout': this._onBlur\n      };\n    },\n    _getMouseEventMap: function () {\n      return {\n        'mousemove': this._onMouseMove,\n        'mouseup': this._onMouseUp\n      };\n    },\n    _getTouchEventMap: function () {\n      return {\n        'touchmove': this._onTouchMove,\n        'touchend': this._onTouchEnd\n      };\n    },\n    // create the `keydown` handler for the i-th handle\n    _createOnKeyDown: function (i) {\n      return function (e) {\n        if (this.props.disabled) return;\n\n        this._start(i);\n\n        this._addHandlers(this._getKeyDownEventMap());\n\n        pauseEvent(e);\n      }.bind(this);\n    },\n    // create the `mousedown` handler for the i-th handle\n    _createOnMouseDown: function (i) {\n      return function (e) {\n        if (this.props.disabled) return;\n\n        var position = this._getMousePosition(e);\n\n        this._start(i, position[0]);\n\n        this._addHandlers(this._getMouseEventMap());\n\n        pauseEvent(e);\n      }.bind(this);\n    },\n    // create the `touchstart` handler for the i-th handle\n    _createOnTouchStart: function (i) {\n      return function (e) {\n        if (this.props.disabled || e.touches.length > 1) return;\n\n        var position = this._getTouchPosition(e);\n\n        this.startPosition = position;\n        this.isScrolling = undefined; // don't know yet if the user is trying to scroll\n\n        this._start(i, position[0]);\n\n        this._addHandlers(this._getTouchEventMap());\n\n        stopPropagation(e);\n      }.bind(this);\n    },\n    _addHandlers: function (eventMap) {\n      for (var key in eventMap) {\n        document.addEventListener(key, eventMap[key], false);\n      }\n    },\n    _removeHandlers: function (eventMap) {\n      for (var key in eventMap) {\n        document.removeEventListener(key, eventMap[key], false);\n      }\n    },\n    _start: function (i, position) {\n      var activeEl = document.activeElement;\n      var handleRef = this.refs['handle' + i]; // if activeElement is body window will lost focus in IE9\n\n      if (activeEl && activeEl != document.body && activeEl != handleRef) {\n        activeEl.blur && activeEl.blur();\n      }\n\n      this.hasMoved = false;\n\n      this._fireChangeEvent('onBeforeChange');\n\n      var zIndices = this.state.zIndices;\n      zIndices.splice(zIndices.indexOf(i), 1); // remove wherever the element is\n\n      zIndices.push(i); // add to end\n\n      this.setState({\n        startValue: this.state.value[i],\n        startPosition: position,\n        index: i,\n        zIndices: zIndices\n      });\n    },\n    _onMouseUp: function () {\n      this._onEnd(this._getMouseEventMap());\n    },\n    _onTouchEnd: function () {\n      this._onEnd(this._getTouchEventMap());\n    },\n    _onBlur: function () {\n      this._onEnd(this._getKeyDownEventMap());\n    },\n    _onEnd: function (eventMap) {\n      this._removeHandlers(eventMap);\n\n      this.setState({\n        index: -1\n      }, this._fireChangeEvent.bind(this, 'onAfterChange'));\n    },\n    _onMouseMove: function (e) {\n      var position = this._getMousePosition(e);\n\n      var diffPosition = this._getDiffPosition(position[0]);\n\n      var newValue = this._getValueFromPosition(diffPosition);\n\n      this._move(newValue);\n    },\n    _onTouchMove: function (e) {\n      if (e.touches.length > 1) return;\n\n      var position = this._getTouchPosition(e);\n\n      if (typeof this.isScrolling === 'undefined') {\n        var diffMainDir = position[0] - this.startPosition[0];\n        var diffScrollDir = position[1] - this.startPosition[1];\n        this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (this.isScrolling) {\n        this.setState({\n          index: -1\n        });\n        return;\n      }\n\n      pauseEvent(e);\n\n      var diffPosition = this._getDiffPosition(position[0]);\n\n      var newValue = this._getValueFromPosition(diffPosition);\n\n      this._move(newValue);\n    },\n    _onKeyDown: function (e) {\n      if (e.ctrlKey || e.shiftKey || e.altKey) return;\n\n      switch (e.key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n          return this._moveDownOneStep();\n\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          return this._moveUpOneStep();\n\n        case \"Home\":\n          return this._move(this.props.min);\n\n        case \"End\":\n          return this._move(this.props.max);\n\n        default:\n          return;\n      }\n    },\n    _moveUpOneStep: function () {\n      var oldValue = this.state.value[this.state.index];\n      var newValue = oldValue + this.props.step;\n\n      this._move(Math.min(newValue, this.props.max));\n    },\n    _moveDownOneStep: function () {\n      var oldValue = this.state.value[this.state.index];\n      var newValue = oldValue - this.props.step;\n\n      this._move(Math.max(newValue, this.props.min));\n    },\n    _getValueFromPosition: function (position) {\n      var diffValue = position / (this.state.sliderLength - this.state.handleSize) * (this.props.max - this.props.min);\n      return this._trimAlignValue(this.state.startValue + diffValue);\n    },\n    _getDiffPosition: function (position) {\n      var diffPosition = position - this.state.startPosition;\n      if (this.props.invert) diffPosition *= -1;\n      return diffPosition;\n    },\n    _move: function (newValue) {\n      this.hasMoved = true;\n      var props = this.props;\n      var state = this.state;\n      var index = state.index;\n      var value = state.value;\n      var length = value.length;\n      var oldValue = value[index];\n      var minDistance = props.minDistance; // if \"pearling\" (= handles pushing each other) is disabled,\n      // prevent the handle from getting closer than `minDistance` to the previous or next handle.\n\n      if (!props.pearling) {\n        if (index > 0) {\n          var valueBefore = value[index - 1];\n\n          if (newValue < valueBefore + minDistance) {\n            newValue = valueBefore + minDistance;\n          }\n        }\n\n        if (index < length - 1) {\n          var valueAfter = value[index + 1];\n\n          if (newValue > valueAfter - minDistance) {\n            newValue = valueAfter - minDistance;\n          }\n        }\n      }\n\n      value[index] = newValue; // if \"pearling\" is enabled, let the current handle push the pre- and succeeding handles.\n\n      if (props.pearling && length > 1) {\n        if (newValue > oldValue) {\n          this._pushSucceeding(value, minDistance, index);\n\n          this._trimSucceeding(length, value, minDistance, props.max);\n        } else if (newValue < oldValue) {\n          this._pushPreceding(value, minDistance, index);\n\n          this._trimPreceding(length, value, minDistance, props.min);\n        }\n      } // Normally you would use `shouldComponentUpdate`, but since the slider is a low-level component,\n      // the extra complexity might be worth the extra performance.\n\n\n      if (newValue !== oldValue) {\n        this.setState({\n          value: value\n        }, this._fireChangeEvent.bind(this, 'onChange'));\n      }\n    },\n    _pushSucceeding: function (value, minDistance, index) {\n      var i, padding;\n\n      for (i = index, padding = value[i] + minDistance; value[i + 1] != null && padding > value[i + 1]; i++, padding = value[i] + minDistance) {\n        value[i + 1] = this._alignValue(padding);\n      }\n    },\n    _trimSucceeding: function (length, nextValue, minDistance, max) {\n      for (var i = 0; i < length; i++) {\n        var padding = max - i * minDistance;\n\n        if (nextValue[length - 1 - i] > padding) {\n          nextValue[length - 1 - i] = padding;\n        }\n      }\n    },\n    _pushPreceding: function (value, minDistance, index) {\n      var i, padding;\n\n      for (i = index, padding = value[i] - minDistance; value[i - 1] != null && padding < value[i - 1]; i--, padding = value[i] - minDistance) {\n        value[i - 1] = this._alignValue(padding);\n      }\n    },\n    _trimPreceding: function (length, nextValue, minDistance, min) {\n      for (var i = 0; i < length; i++) {\n        var padding = min + i * minDistance;\n\n        if (nextValue[i] < padding) {\n          nextValue[i] = padding;\n        }\n      }\n    },\n    _axisKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'X';\n      if (orientation === 'vertical') return 'Y';\n    },\n    _orthogonalAxisKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'Y';\n      if (orientation === 'vertical') return 'X';\n    },\n    _posMinKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return this.props.invert ? 'right' : 'left';\n      if (orientation === 'vertical') return this.props.invert ? 'bottom' : 'top';\n    },\n    _posMaxKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return this.props.invert ? 'left' : 'right';\n      if (orientation === 'vertical') return this.props.invert ? 'top' : 'bottom';\n    },\n    _sizeKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'clientWidth';\n      if (orientation === 'vertical') return 'clientHeight';\n    },\n    _trimAlignValue: function (val, props) {\n      return this._alignValue(this._trimValue(val, props), props);\n    },\n    _trimValue: function (val, props) {\n      props = props || this.props;\n      if (val <= props.min) val = props.min;\n      if (val >= props.max) val = props.max;\n      return val;\n    },\n    _alignValue: function (val, props) {\n      props = props || this.props;\n      var valModStep = (val - props.min) % props.step;\n      var alignValue = val - valModStep;\n\n      if (Math.abs(valModStep) * 2 >= props.step) {\n        alignValue += valModStep > 0 ? props.step : -props.step;\n      }\n\n      return parseFloat(alignValue.toFixed(5));\n    },\n    _renderHandle: function (style, child, i) {\n      var className = this.props.handleClassName + ' ' + (this.props.handleClassName + '-' + i) + ' ' + (this.state.index === i ? this.props.handleActiveClassName : '');\n      return React.createElement('div', {\n        ref: 'handle' + i,\n        key: 'handle' + i,\n        className: className,\n        style: style,\n        onMouseDown: this._createOnMouseDown(i),\n        onTouchStart: this._createOnTouchStart(i),\n        onFocus: this._createOnKeyDown(i),\n        tabIndex: 0,\n        role: \"slider\",\n        \"aria-valuenow\": this.state.value[i],\n        \"aria-valuemin\": this.props.min,\n        \"aria-valuemax\": this.props.max\n      }, child);\n    },\n    _renderHandles: function (offset) {\n      var length = offset.length;\n      var styles = this.tempArray;\n\n      for (var i = 0; i < length; i++) {\n        styles[i] = this._buildHandleStyle(offset[i], i);\n      }\n\n      var res = this.tempArray;\n      var renderHandle = this._renderHandle;\n\n      if (React.Children.count(this.props.children) > 0) {\n        React.Children.forEach(this.props.children, function (child, i) {\n          res[i] = renderHandle(styles[i], child, i);\n        });\n      } else {\n        for (i = 0; i < length; i++) {\n          res[i] = renderHandle(styles[i], null, i);\n        }\n      }\n\n      return res;\n    },\n    _renderBar: function (i, offsetFrom, offsetTo) {\n      return React.createElement('div', {\n        key: 'bar' + i,\n        ref: 'bar' + i,\n        className: this.props.barClassName + ' ' + this.props.barClassName + '-' + i,\n        style: this._buildBarStyle(offsetFrom, this.state.upperBound - offsetTo)\n      });\n    },\n    _renderBars: function (offset) {\n      var bars = [];\n      var lastIndex = offset.length - 1;\n      bars.push(this._renderBar(0, 0, offset[0]));\n\n      for (var i = 0; i < lastIndex; i++) {\n        bars.push(this._renderBar(i + 1, offset[i], offset[i + 1]));\n      }\n\n      bars.push(this._renderBar(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n      return bars;\n    },\n    _onSliderMouseDown: function (e) {\n      if (this.props.disabled) return;\n      this.hasMoved = false;\n\n      if (!this.props.snapDragDisabled) {\n        var position = this._getMousePosition(e);\n\n        this._forceValueFromPosition(position[0], function (i) {\n          this._fireChangeEvent('onChange');\n\n          this._start(i, position[0]);\n\n          this._addHandlers(this._getMouseEventMap());\n        }.bind(this));\n      }\n\n      pauseEvent(e);\n    },\n    _onSliderClick: function (e) {\n      if (this.props.disabled) return;\n\n      if (this.props.onSliderClick && !this.hasMoved) {\n        var position = this._getMousePosition(e);\n\n        var valueAtPos = this._trimAlignValue(this._calcValue(this._calcOffsetFromPosition(position[0])));\n\n        this.props.onSliderClick(valueAtPos);\n      }\n    },\n    _fireChangeEvent: function (event) {\n      if (this.props[event]) {\n        this.props[event](undoEnsureArray(this.state.value));\n      }\n    },\n    render: function () {\n      var state = this.state;\n      var props = this.props;\n      var offset = this.tempArray;\n      var value = state.value;\n      var l = value.length;\n\n      for (var i = 0; i < l; i++) {\n        offset[i] = this._calcOffset(value[i], i);\n      }\n\n      var bars = props.withBars ? this._renderBars(offset) : null;\n\n      var handles = this._renderHandles(offset);\n\n      return React.createElement('div', {\n        ref: 'slider',\n        style: {\n          position: 'relative'\n        },\n        className: props.className + (props.disabled ? ' disabled' : ''),\n        onMouseDown: this._onSliderMouseDown,\n        onClick: this._onSliderClick\n      }, bars, handles);\n    }\n  });\n  return ReactSlider;\n});","map":{"version":3,"sources":["/Users/asknteach/projects/fetch/portal.fetch.tech.frontend/node_modules/react-slider/react-slider.js"],"names":["root","factory","define","amd","exports","module","require","ReactSlider","React","PropTypes","createReactClass","pauseEvent","e","stopPropagation","preventDefault","linspace","min","max","count","range","res","i","push","ensureArray","x","Array","isArray","undoEnsureArray","length","displayName","propTypes","number","step","minDistance","defaultValue","oneOfType","arrayOf","value","orientation","oneOf","className","string","handleClassName","handleActiveClassName","withBars","bool","barClassName","pearling","disabled","snapDragDisabled","invert","onBeforeChange","func","onChange","onAfterChange","onSliderClick","getDefaultProps","getInitialState","_or","props","tempArray","slice","pendingResizeTimeouts","zIndices","_trimAlignValue","index","upperBound","sliderLength","componentWillReceiveProps","newProps","state","_handleResize","Children","children","console","warn","constructor","componentDidMount","window","addEventListener","componentWillUnmount","_clearPendingResizeTimeouts","removeEventListener","getValue","resizeTimeout","setTimeout","shift","slider","refs","handle","handle0","rect","getBoundingClientRect","size","_sizeKey","sliderMax","_posMaxKey","sliderMin","_posMinKey","setState","Math","abs","handleSize","sliderStart","bind","nextTimeout","clearTimeout","_calcOffset","ratio","_calcValue","offset","_buildHandleStyle","style","position","willChange","zIndex","indexOf","_buildBarStyle","obj","_getClosestIndex","pixelOffset","minDist","Number","MAX_VALUE","closestIndex","l","dist","_calcOffsetFromPosition","_forceValueFromPosition","callback","nextValue","_getMousePosition","_axisKey","_orthogonalAxisKey","_getTouchPosition","touch","touches","_getKeyDownEventMap","_onKeyDown","_onBlur","_getMouseEventMap","_onMouseMove","_onMouseUp","_getTouchEventMap","_onTouchMove","_onTouchEnd","_createOnKeyDown","_start","_addHandlers","_createOnMouseDown","_createOnTouchStart","startPosition","isScrolling","undefined","eventMap","key","document","_removeHandlers","activeEl","activeElement","handleRef","body","blur","hasMoved","_fireChangeEvent","splice","startValue","_onEnd","diffPosition","_getDiffPosition","newValue","_getValueFromPosition","_move","diffMainDir","diffScrollDir","ctrlKey","shiftKey","altKey","_moveDownOneStep","_moveUpOneStep","oldValue","diffValue","valueBefore","valueAfter","_pushSucceeding","_trimSucceeding","_pushPreceding","_trimPreceding","padding","_alignValue","val","_trimValue","valModStep","alignValue","parseFloat","toFixed","_renderHandle","child","createElement","ref","onMouseDown","onTouchStart","onFocus","tabIndex","role","_renderHandles","styles","renderHandle","forEach","_renderBar","offsetFrom","offsetTo","_renderBars","bars","lastIndex","_onSliderMouseDown","_onSliderClick","valueAtPos","event","render","handles","onClick"],"mappings":"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","sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['react','prop-types','create-react-class'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('react'),require('prop-types'),require('create-react-class'));\n  } else {\n    root.ReactSlider = factory(root.React,root.PropTypes,root.createReactClass);\n  }\n}(this, function (React, PropTypes, createReactClass) {\n\n  /**\n   * To prevent text selection while dragging.\n   * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n   */\n  function pauseEvent(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    if (e.preventDefault) e.preventDefault();\n    return false;\n  }\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n  }\n\n  /**\n   * Spreads `count` values equally between `min` and `max`.\n   */\n  function linspace(min, max, count) {\n    var range = (max - min) / (count - 1);\n    var res = [];\n    for (var i = 0; i < count; i++) {\n      res.push(min + range * i);\n    }\n    return res;\n  }\n\n  function ensureArray(x) {\n    return x == null ? [] : Array.isArray(x) ? x : [x];\n  }\n\n  function undoEnsureArray(x) {\n    return x != null && x.length === 1 ? x[0] : x;\n  }\n\n  // undoEnsureArray(ensureArray(x)) === x\n\n  var ReactSlider = createReactClass({\n    displayName: 'ReactSlider',\n\n    propTypes: {\n\n      /**\n       * The minimum value of the slider.\n       */\n      min: PropTypes.number,\n\n      /**\n       * The maximum value of the slider.\n       */\n      max: PropTypes.number,\n\n      /**\n       * Value to be added or subtracted on each step the slider makes.\n       * Must be greater than zero.\n       * `max - min` should be evenly divisible by the step value.\n       */\n      step: PropTypes.number,\n\n      /**\n       * The minimal distance between any pair of handles.\n       * Must be positive, but zero means they can sit on top of each other.\n       */\n      minDistance: PropTypes.number,\n\n      /**\n       * Determines the initial positions of the handles and the number of handles if the component has no children.\n       *\n       * If a number is passed a slider with one handle will be rendered.\n       * If an array is passed each value will determine the position of one handle.\n       * The values in the array must be sorted.\n       * If the component has children, the length of the array must match the number of children.\n       */\n      defaultValue: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(PropTypes.number)\n      ]),\n\n      /**\n       * Like `defaultValue` but for [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n       */\n      value: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(PropTypes.number)\n      ]),\n\n      /**\n       * Determines whether the slider moves horizontally (from left to right) or vertically (from top to bottom).\n       */\n      orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n      /**\n       * The css class set on the slider node.\n       */\n      className: PropTypes.string,\n\n      /**\n       * The css class set on each handle node.\n       *\n       * In addition each handle will receive a numbered css class of the form `${handleClassName}-${i}`,\n       * e.g. `handle-0`, `handle-1`, ...\n       */\n      handleClassName: PropTypes.string,\n\n      /**\n       * The css class set on the handle that is currently being moved.\n       */\n      handleActiveClassName: PropTypes.string,\n\n      /**\n       * If `true` bars between the handles will be rendered.\n       */\n      withBars: PropTypes.bool,\n\n      /**\n       * The css class set on the bars between the handles.\n       * In addition bar fragment will receive a numbered css class of the form `${barClassName}-${i}`,\n       * e.g. `bar-0`, `bar-1`, ...\n       */\n      barClassName: PropTypes.string,\n\n      /**\n       * If `true` the active handle will push other handles\n       * within the constraints of `min`, `max`, `step` and `minDistance`.\n       */\n      pearling: PropTypes.bool,\n\n      /**\n       * If `true` the handles can't be moved.\n       */\n      disabled: PropTypes.bool,\n\n      /**\n       * Disables handle move when clicking the slider bar\n       */\n      snapDragDisabled: PropTypes.bool,\n\n      /**\n       * Inverts the slider.\n       */\n      invert: PropTypes.bool,\n\n      /**\n       * Callback called before starting to move a handle.\n       */\n      onBeforeChange: PropTypes.func,\n\n      /**\n       * Callback called on every value change.\n       */\n      onChange: PropTypes.func,\n\n      /**\n       * Callback called only after moving a handle has ended.\n       */\n      onAfterChange: PropTypes.func,\n\n      /**\n       *  Callback called when the the slider is clicked (handle or bars).\n       *  Receives the value at the clicked position as argument.\n       */\n      onSliderClick: PropTypes.func\n    },\n\n    getDefaultProps: function () {\n      return {\n        min: 0,\n        max: 100,\n        step: 1,\n        minDistance: 0,\n        defaultValue: 0,\n        orientation: 'horizontal',\n        className: 'slider',\n        handleClassName: 'handle',\n        handleActiveClassName: 'active',\n        barClassName: 'bar',\n        withBars: false,\n        pearling: false,\n        disabled: false,\n        snapDragDisabled: false,\n        invert: false\n      };\n    },\n\n    getInitialState: function () {\n      var value = this._or(ensureArray(this.props.value), ensureArray(this.props.defaultValue));\n\n      // reused throughout the component to store results of iterations over `value`\n      this.tempArray = value.slice();\n\n      // array for storing resize timeouts ids\n      this.pendingResizeTimeouts = [];\n\n      var zIndices = [];\n      for (var i = 0; i < value.length; i++) {\n        value[i] = this._trimAlignValue(value[i], this.props);\n        zIndices.push(i);\n      }\n\n      return {\n        index: -1,\n        upperBound: 0,\n        sliderLength: 0,\n        value: value,\n        zIndices: zIndices\n      };\n    },\n\n    // Keep the internal `value` consistent with an outside `value` if present.\n    // This basically allows the slider to be a controlled component.\n    componentWillReceiveProps: function (newProps) {\n      var value = this._or(ensureArray(newProps.value), this.state.value);\n\n      // ensure the array keeps the same size as `value`\n      this.tempArray = value.slice();\n\n      for (var i = 0; i < value.length; i++) {\n        this.state.value[i] = this._trimAlignValue(value[i], newProps);\n      }\n      if (this.state.value.length > value.length)\n        this.state.value.length = value.length;\n\n      // If an upperBound has not yet been determined (due to the component being hidden\n      // during the mount event, or during the last resize), then calculate it now\n      if (this.state.upperBound === 0) {\n        this._handleResize();\n      }\n    },\n\n    // Check if the arity of `value` or `defaultValue` matches the number of children (= number of custom handles).\n    // If no custom handles are provided, just returns `value` if present and `defaultValue` otherwise.\n    // If custom handles are present but neither `value` nor `defaultValue` are applicable the handles are spread out\n    // equally.\n    // TODO: better name? better solution?\n    _or: function (value, defaultValue) {\n      var count = React.Children.count(this.props.children);\n      switch (count) {\n        case 0:\n          return value.length > 0 ? value : defaultValue;\n        case value.length:\n          return value;\n        case defaultValue.length:\n          return defaultValue;\n        default:\n          if (value.length !== count || defaultValue.length !== count) {\n            console.warn(this.constructor.displayName + \": Number of values does not match number of children.\");\n          }\n          return linspace(this.props.min, this.props.max, count);\n      }\n    },\n\n    componentDidMount: function () {\n      window.addEventListener('resize', this._handleResize);\n      this._handleResize();\n    },\n\n    componentWillUnmount: function () {\n      this._clearPendingResizeTimeouts();\n      window.removeEventListener('resize', this._handleResize);\n    },\n\n    getValue: function () {\n      return undoEnsureArray(this.state.value);\n    },\n\n    _handleResize: function () {\n      // setTimeout of 0 gives element enough time to have assumed its new size if it is being resized\n      var resizeTimeout = window.setTimeout(function() {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        this.pendingResizeTimeouts.shift();\n\n        var slider = this.refs.slider;\n        var handle = this.refs.handle0;\n        var rect = slider.getBoundingClientRect();\n\n        var size = this._sizeKey();\n\n        var sliderMax = rect[this._posMaxKey()];\n        var sliderMin = rect[this._posMinKey()];\n\n        this.setState({\n          upperBound: slider[size] - handle[size],\n          sliderLength: Math.abs(sliderMax - sliderMin),\n          handleSize: handle[size],\n          sliderStart: this.props.invert ? sliderMax : sliderMin\n        });\n      }.bind(this), 0);\n\n      this.pendingResizeTimeouts.push(resizeTimeout);\n    },\n\n    // clear all pending timeouts to avoid error messages after unmounting\n    _clearPendingResizeTimeouts: function() {\n      do {\n        var nextTimeout = this.pendingResizeTimeouts.shift();\n\n        clearTimeout(nextTimeout);\n      } while (this.pendingResizeTimeouts.length);\n    },\n\n    // calculates the offset of a handle in pixels based on its value.\n    _calcOffset: function (value) {\n      var range = this.props.max - this.props.min;\n      if (range === 0) {\n        return 0;\n      }\n      var ratio = (value - this.props.min) / range;\n      return ratio * this.state.upperBound;\n    },\n\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `_calcOffset`.\n    _calcValue: function (offset) {\n      var ratio = offset / this.state.upperBound;\n      return ratio * (this.props.max - this.props.min) + this.props.min;\n    },\n\n    _buildHandleStyle: function (offset, i) {\n      var style = {\n        position: 'absolute',\n        willChange: this.state.index >= 0 ? this._posMinKey() : '',\n        zIndex: this.state.zIndices.indexOf(i) + 1\n      };\n      style[this._posMinKey()] = offset + 'px';\n      return style;\n    },\n\n    _buildBarStyle: function (min, max) {\n      var obj = {\n        position: 'absolute',\n        willChange: this.state.index >= 0 ? this._posMinKey() + ',' + this._posMaxKey() : ''\n      };\n      obj[this._posMinKey()] = min;\n      obj[this._posMaxKey()] = max;\n      return obj;\n    },\n\n    _getClosestIndex: function (pixelOffset) {\n      var minDist = Number.MAX_VALUE;\n      var closestIndex = -1;\n\n      var value = this.state.value;\n      var l = value.length;\n\n      for (var i = 0; i < l; i++) {\n        var offset = this._calcOffset(value[i]);\n        var dist = Math.abs(pixelOffset - offset);\n        if (dist < minDist) {\n          minDist = dist;\n          closestIndex = i;\n        }\n      }\n\n      return closestIndex;\n    },\n\n    _calcOffsetFromPosition: function (position) {\n      var pixelOffset = position - this.state.sliderStart;\n      if (this.props.invert) pixelOffset = this.state.sliderLength - pixelOffset;\n      pixelOffset -= (this.state.handleSize / 2);\n      return pixelOffset;\n    },\n\n    // Snaps the nearest handle to the value corresponding to `position` and calls `callback` with that handle's index.\n    _forceValueFromPosition: function (position, callback) {\n      var pixelOffset = this._calcOffsetFromPosition(position);\n      var closestIndex = this._getClosestIndex(pixelOffset);\n      var nextValue = this._trimAlignValue(this._calcValue(pixelOffset));\n\n      var value = this.state.value.slice(); // Clone this.state.value since we'll modify it temporarily\n      value[closestIndex] = nextValue;\n\n      // Prevents the slider from shrinking below `props.minDistance`\n      for (var i = 0; i < value.length - 1; i += 1) {\n        if (value[i + 1] - value[i] < this.props.minDistance) return;\n      }\n\n      this.setState({value: value}, callback.bind(this, closestIndex));\n    },\n\n    _getMousePosition: function (e) {\n      return [\n        e['page' + this._axisKey()],\n        e['page' + this._orthogonalAxisKey()]\n      ];\n    },\n\n    _getTouchPosition: function (e) {\n      var touch = e.touches[0];\n      return [\n        touch['page' + this._axisKey()],\n        touch['page' + this._orthogonalAxisKey()]\n      ];\n    },\n\n    _getKeyDownEventMap: function () {\n      return {\n        'keydown': this._onKeyDown,\n        'focusout': this._onBlur\n      }\n    },\n\n    _getMouseEventMap: function () {\n      return {\n        'mousemove': this._onMouseMove,\n        'mouseup': this._onMouseUp\n      }\n    },\n\n    _getTouchEventMap: function () {\n      return {\n        'touchmove': this._onTouchMove,\n        'touchend': this._onTouchEnd\n      }\n    },\n\n    // create the `keydown` handler for the i-th handle\n    _createOnKeyDown: function (i) {\n      return function (e) {\n        if (this.props.disabled) return;\n        this._start(i);\n        this._addHandlers(this._getKeyDownEventMap());\n        pauseEvent(e);\n      }.bind(this);\n    },\n\n    // create the `mousedown` handler for the i-th handle\n    _createOnMouseDown: function (i) {\n      return function (e) {\n        if (this.props.disabled) return;\n        var position = this._getMousePosition(e);\n        this._start(i, position[0]);\n        this._addHandlers(this._getMouseEventMap());\n        pauseEvent(e);\n      }.bind(this);\n    },\n\n    // create the `touchstart` handler for the i-th handle\n    _createOnTouchStart: function (i) {\n      return function (e) {\n        if (this.props.disabled || e.touches.length > 1) return;\n        var position = this._getTouchPosition(e);\n        this.startPosition = position;\n        this.isScrolling = undefined; // don't know yet if the user is trying to scroll\n        this._start(i, position[0]);\n        this._addHandlers(this._getTouchEventMap());\n        stopPropagation(e);\n      }.bind(this);\n    },\n\n    _addHandlers: function (eventMap) {\n      for (var key in eventMap) {\n        document.addEventListener(key, eventMap[key], false);\n      }\n    },\n\n    _removeHandlers: function (eventMap) {\n      for (var key in eventMap) {\n        document.removeEventListener(key, eventMap[key], false);\n      }\n    },\n\n    _start: function (i, position) {\n      var activeEl = document.activeElement;\n      var handleRef = this.refs['handle' + i];\n      // if activeElement is body window will lost focus in IE9\n      if (activeEl && activeEl != document.body && activeEl != handleRef) {\n        activeEl.blur && activeEl.blur();\n      }\n\n      this.hasMoved = false;\n\n      this._fireChangeEvent('onBeforeChange');\n\n      var zIndices = this.state.zIndices;\n      zIndices.splice(zIndices.indexOf(i), 1); // remove wherever the element is\n      zIndices.push(i); // add to end\n\n      this.setState({\n        startValue: this.state.value[i],\n        startPosition: position,\n        index: i,\n        zIndices: zIndices\n      });\n    },\n\n    _onMouseUp: function () {\n      this._onEnd(this._getMouseEventMap());\n    },\n\n    _onTouchEnd: function () {\n      this._onEnd(this._getTouchEventMap());\n    },\n\n    _onBlur: function () {\n      this._onEnd(this._getKeyDownEventMap());\n    },\n\n    _onEnd: function (eventMap) {\n      this._removeHandlers(eventMap);\n      this.setState({index: -1}, this._fireChangeEvent.bind(this, 'onAfterChange'));\n    },\n\n    _onMouseMove: function (e) {\n      var position = this._getMousePosition(e);\n      var diffPosition = this._getDiffPosition(position[0]);\n      var newValue = this._getValueFromPosition(diffPosition);\n      this._move(newValue);\n    },\n\n    _onTouchMove: function (e) {\n      if (e.touches.length > 1) return;\n\n      var position = this._getTouchPosition(e);\n\n      if (typeof this.isScrolling === 'undefined') {\n        var diffMainDir = position[0] - this.startPosition[0];\n        var diffScrollDir = position[1] - this.startPosition[1];\n        this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (this.isScrolling) {\n        this.setState({index: -1});\n        return;\n      }\n\n      pauseEvent(e);\n\n      var diffPosition = this._getDiffPosition(position[0]);\n      var newValue = this._getValueFromPosition(diffPosition);\n\n      this._move(newValue);\n    },\n\n    _onKeyDown: function (e) {\n      if (e.ctrlKey || e.shiftKey || e.altKey) return;\n      switch (e.key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n          return this._moveDownOneStep();\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          return this._moveUpOneStep();\n        case \"Home\":\n          return this._move(this.props.min);\n        case \"End\":\n          return this._move(this.props.max);\n        default:\n          return;\n      }\n    },\n\n    _moveUpOneStep: function () {\n      var oldValue = this.state.value[this.state.index];\n      var newValue = oldValue + this.props.step;\n      this._move(Math.min(newValue, this.props.max));\n    },\n\n    _moveDownOneStep: function () {\n      var oldValue = this.state.value[this.state.index];\n      var newValue = oldValue - this.props.step;\n      this._move(Math.max(newValue, this.props.min));\n    },\n\n    _getValueFromPosition: function (position) {\n      var diffValue = position / (this.state.sliderLength - this.state.handleSize) * (this.props.max - this.props.min);\n      return this._trimAlignValue(this.state.startValue + diffValue);\n    },\n\n    _getDiffPosition: function (position) {\n      var diffPosition = position - this.state.startPosition;\n      if (this.props.invert) diffPosition *= -1;\n      return diffPosition;\n    },\n\n    _move: function (newValue) {\n      this.hasMoved = true;\n\n      var props = this.props;\n      var state = this.state;\n      var index = state.index;\n\n      var value = state.value;\n      var length = value.length;\n      var oldValue = value[index];\n\n      var minDistance = props.minDistance;\n\n      // if \"pearling\" (= handles pushing each other) is disabled,\n      // prevent the handle from getting closer than `minDistance` to the previous or next handle.\n      if (!props.pearling) {\n        if (index > 0) {\n          var valueBefore = value[index - 1];\n          if (newValue < valueBefore + minDistance) {\n            newValue = valueBefore + minDistance;\n          }\n        }\n\n        if (index < length - 1) {\n          var valueAfter = value[index + 1];\n          if (newValue > valueAfter - minDistance) {\n            newValue = valueAfter - minDistance;\n          }\n        }\n      }\n\n      value[index] = newValue;\n\n      // if \"pearling\" is enabled, let the current handle push the pre- and succeeding handles.\n      if (props.pearling && length > 1) {\n        if (newValue > oldValue) {\n          this._pushSucceeding(value, minDistance, index);\n          this._trimSucceeding(length, value, minDistance, props.max);\n        }\n        else if (newValue < oldValue) {\n          this._pushPreceding(value, minDistance, index);\n          this._trimPreceding(length, value, minDistance, props.min);\n        }\n      }\n\n      // Normally you would use `shouldComponentUpdate`, but since the slider is a low-level component,\n      // the extra complexity might be worth the extra performance.\n      if (newValue !== oldValue) {\n        this.setState({value: value}, this._fireChangeEvent.bind(this, 'onChange'));\n      }\n    },\n\n    _pushSucceeding: function (value, minDistance, index) {\n      var i, padding;\n      for (i = index, padding = value[i] + minDistance;\n           value[i + 1] != null && padding > value[i + 1];\n           i++, padding = value[i] + minDistance) {\n        value[i + 1] = this._alignValue(padding);\n      }\n    },\n\n    _trimSucceeding: function (length, nextValue, minDistance, max) {\n      for (var i = 0; i < length; i++) {\n        var padding = max - i * minDistance;\n        if (nextValue[length - 1 - i] > padding) {\n          nextValue[length - 1 - i] = padding;\n        }\n      }\n    },\n\n    _pushPreceding: function (value, minDistance, index) {\n      var i, padding;\n      for (i = index, padding = value[i] - minDistance;\n           value[i - 1] != null && padding < value[i - 1];\n           i--, padding = value[i] - minDistance) {\n        value[i - 1] = this._alignValue(padding);\n      }\n    },\n\n    _trimPreceding: function (length, nextValue, minDistance, min) {\n      for (var i = 0; i < length; i++) {\n        var padding = min + i * minDistance;\n        if (nextValue[i] < padding) {\n          nextValue[i] = padding;\n        }\n      }\n    },\n\n    _axisKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'X';\n      if (orientation === 'vertical') return 'Y';\n    },\n\n    _orthogonalAxisKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'Y';\n      if (orientation === 'vertical') return 'X';\n    },\n\n    _posMinKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return this.props.invert ? 'right' : 'left';\n      if (orientation === 'vertical') return this.props.invert ? 'bottom' : 'top';\n    },\n\n    _posMaxKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return this.props.invert ? 'left' : 'right';\n      if (orientation === 'vertical') return this.props.invert ? 'top' : 'bottom';\n    },\n\n    _sizeKey: function () {\n      var orientation = this.props.orientation;\n      if (orientation === 'horizontal') return 'clientWidth';\n      if (orientation === 'vertical') return 'clientHeight';\n    },\n\n    _trimAlignValue: function (val, props) {\n      return this._alignValue(this._trimValue(val, props), props);\n    },\n\n    _trimValue: function (val, props) {\n      props = props || this.props;\n\n      if (val <= props.min) val = props.min;\n      if (val >= props.max) val = props.max;\n\n      return val;\n    },\n\n    _alignValue: function (val, props) {\n      props = props || this.props;\n\n      var valModStep = (val - props.min) % props.step;\n      var alignValue = val - valModStep;\n\n      if (Math.abs(valModStep) * 2 >= props.step) {\n        alignValue += (valModStep > 0) ? props.step : (-props.step);\n      }\n\n      return parseFloat(alignValue.toFixed(5));\n    },\n\n    _renderHandle: function (style, child, i) {\n      var className = this.props.handleClassName + ' ' +\n        (this.props.handleClassName + '-' + i) + ' ' +\n        (this.state.index === i ? this.props.handleActiveClassName : '');\n\n      return (\n        React.createElement('div', {\n            ref: 'handle' + i,\n            key: 'handle' + i,\n            className: className,\n            style: style,\n            onMouseDown: this._createOnMouseDown(i),\n            onTouchStart: this._createOnTouchStart(i),\n            onFocus: this._createOnKeyDown(i),\n            tabIndex: 0,\n            role: \"slider\",\n            \"aria-valuenow\": this.state.value[i],\n            \"aria-valuemin\": this.props.min,\n            \"aria-valuemax\": this.props.max,\n          },\n          child\n        )\n      );\n    },\n\n    _renderHandles: function (offset) {\n      var length = offset.length;\n\n      var styles = this.tempArray;\n      for (var i = 0; i < length; i++) {\n        styles[i] = this._buildHandleStyle(offset[i], i);\n      }\n\n      var res = this.tempArray;\n      var renderHandle = this._renderHandle;\n      if (React.Children.count(this.props.children) > 0) {\n        React.Children.forEach(this.props.children, function (child, i) {\n          res[i] = renderHandle(styles[i], child, i);\n        });\n      } else {\n        for (i = 0; i < length; i++) {\n          res[i] = renderHandle(styles[i], null, i);\n        }\n      }\n      return res;\n    },\n\n    _renderBar: function (i, offsetFrom, offsetTo) {\n      return (\n        React.createElement('div', {\n          key: 'bar' + i,\n          ref: 'bar' + i,\n          className: this.props.barClassName + ' ' + this.props.barClassName + '-' + i,\n          style: this._buildBarStyle(offsetFrom, this.state.upperBound - offsetTo)\n        })\n      );\n    },\n\n    _renderBars: function (offset) {\n      var bars = [];\n      var lastIndex = offset.length - 1;\n\n      bars.push(this._renderBar(0, 0, offset[0]));\n\n      for (var i = 0; i < lastIndex; i++) {\n        bars.push(this._renderBar(i + 1, offset[i], offset[i + 1]));\n      }\n\n      bars.push(this._renderBar(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n\n      return bars;\n    },\n\n    _onSliderMouseDown: function (e) {\n      if (this.props.disabled) return;\n      this.hasMoved = false;\n      if (!this.props.snapDragDisabled) {\n        var position = this._getMousePosition(e);\n        this._forceValueFromPosition(position[0], function (i) {\n          this._fireChangeEvent('onChange');\n          this._start(i, position[0]);\n          this._addHandlers(this._getMouseEventMap());\n        }.bind(this));\n      }\n\n      pauseEvent(e);\n    },\n\n    _onSliderClick: function (e) {\n      if (this.props.disabled) return;\n\n      if (this.props.onSliderClick && !this.hasMoved) {\n        var position = this._getMousePosition(e);\n        var valueAtPos = this._trimAlignValue(this._calcValue(this._calcOffsetFromPosition(position[0])));\n        this.props.onSliderClick(valueAtPos);\n      }\n    },\n\n    _fireChangeEvent: function (event) {\n      if (this.props[event]) {\n        this.props[event](undoEnsureArray(this.state.value));\n      }\n    },\n\n    render: function () {\n      var state = this.state;\n      var props = this.props;\n\n      var offset = this.tempArray;\n      var value = state.value;\n      var l = value.length;\n      for (var i = 0; i < l; i++) {\n        offset[i] = this._calcOffset(value[i], i);\n      }\n\n      var bars = props.withBars ? this._renderBars(offset) : null;\n      var handles = this._renderHandles(offset);\n\n      return (\n        React.createElement('div', {\n            ref: 'slider',\n            style: {position: 'relative'},\n            className: props.className + (props.disabled ? ' disabled' : ''),\n            onMouseDown: this._onSliderMouseDown,\n            onClick: this._onSliderClick\n          },\n          bars,\n          handles\n        )\n      );\n    }\n  });\n\n  return ReactSlider;\n}));\n"]},"metadata":{},"sourceType":"script"}