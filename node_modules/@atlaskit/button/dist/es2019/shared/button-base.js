/** @jsx jsx */
import React, { useCallback, useEffect, useRef } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import { name as packageName, version as packageVersion, } from '../version.json';
import blockEvents from './block-events';
import { getContentStyle, getFadingCss, getIconStyle, overlayCss } from './css';
import useAutoFocus from './use-auto-focus';
function noop() { }
// Disabled buttons will still publish events for nested elements in webkit.
// We are disabling pointer events on child elements so that
// the button will always be the target of events
// Note: firefox does not have this behaviour for child elements
const noPointerEventsOnChildrenCss = {
    '> *': {
        pointerEvents: 'none',
    },
};
export default React.forwardRef(function ButtonBase(props, ref) {
    const { appearance = 'default', buttonCss, spacing = 'default', autoFocus = false, isDisabled = false, shouldFitContainer = false, isSelected = false, iconBefore, iconAfter, children, className, href, overlay, tabIndex = 0, type = !href ? 'button' : undefined, onMouseDown: providedOnMouseDown = noop, onClick: providedOnClick = noop, 
    // use the provided component prop,
    // else default to anchor if there is a href, and button if there is no href
    component: Component = href ? 'a' : 'button', testId, 
    // I don't think this should be in button, but for now it is
    analyticsContext, ...rest } = props;
    const ourRef = useRef();
    const setRef = useCallback((node) => {
        ourRef.current = node;
        if (ref == null) {
            return;
        }
        if (typeof ref === 'function') {
            ref(node);
            return;
        }
        // @ts-ignore
        ref.current = node;
    }, [ourRef, ref]);
    // Cross browser auto focusing is pretty broken, so we are doing it ourselves
    useAutoFocus(ourRef, autoFocus);
    const onClick = usePlatformLeafEventHandler({
        fn: providedOnClick,
        action: 'clicked',
        componentName: 'button',
        packageName,
        packageVersion,
        analyticsData: analyticsContext,
    });
    // Button currently calls preventDefault, which is not standard button behaviour
    const onMouseDown = useCallback((event) => {
        event.preventDefault();
        providedOnMouseDown(event);
    }, [providedOnMouseDown]);
    // Lose focus when becoming disabled (standard button behaviour)
    useEffect(() => {
        const el = ourRef.current;
        if (isDisabled && el && el === document.activeElement) {
            el.blur();
        }
    }, [isDisabled]);
    // we are 'disabling' input with a button when there is an overlay
    const hasOverlay = Boolean(overlay);
    const fadeCss = getFadingCss({ hasOverlay });
    const isInteractive = !isDisabled && !hasOverlay;
    return (jsx(Component, Object.assign({}, rest, { css: [buttonCss, isInteractive ? null : noPointerEventsOnChildrenCss], className: className, ref: setRef, onClick: onClick, onMouseDown: onMouseDown, disabled: isDisabled, href: isInteractive ? href : undefined, "data-has-overlay": hasOverlay ? true : undefined, "data-testid": testId, type: type, 
        // Adding a tab index so element is always focusable, even when not a <button> or <a>
        // Disabling focus via keyboard navigation when disabled
        // as this is standard button behaviour
        tabIndex: isDisabled ? -1 : tabIndex }, blockEvents({ isInteractive })),
        iconBefore ? (jsx("span", { css: [fadeCss, getIconStyle({ spacing })] }, iconBefore)) : null,
        children ? (jsx("span", { css: [fadeCss, getContentStyle({ spacing })] }, children)) : null,
        iconAfter ? (jsx("span", { css: [fadeCss, getIconStyle({ spacing })] }, iconAfter)) : null,
        overlay ? jsx("span", { css: overlayCss }, overlay) : null));
});
//# sourceMappingURL=button-base.js.map