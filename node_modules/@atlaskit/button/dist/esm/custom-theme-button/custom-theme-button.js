import { __assign, __read, __rest } from "tslib";
import React, { useCallback, useState } from 'react';
import GlobalTheme from '@atlaskit/theme/components';
import ButtonBase from '../shared/button-base';
import getIsOnlySingleIcon from '../shared/get-is-only-single-icon';
import LoadingSpinner from '../shared/loading-spinner';
import Theme, { defaultThemeFn, getSpecifiers } from './theme';
function getInteractionState(_a) {
    var _b = _a.isDisabled, isDisabled = _b === void 0 ? false : _b, _c = _a.isActive, isActive = _c === void 0 ? false : _c, _d = _a.isFocus, isFocus = _d === void 0 ? false : _d, _e = _a.isHover, isHover = _e === void 0 ? false : _e, _f = _a.isSelected, isSelected = _f === void 0 ? false : _f, _g = _a.isLoading, isLoading = _g === void 0 ? false : _g;
    if (isDisabled) {
        return 'disabled';
    }
    if (isSelected && isFocus) {
        return 'focusSelected';
    }
    if (isSelected) {
        return 'selected';
    }
    // not allowing active or focus style changes while loading
    if (!isLoading && isActive) {
        return 'active';
    }
    if (!isLoading && isHover) {
        return 'hover';
    }
    if (isFocus) {
        return 'focus';
    }
    return 'default';
}
var initial = { isHover: false, isActive: false, isFocus: false };
var CustomThemeButton = React.memo(React.forwardRef(function CustomThemeButton(_a, ref) {
    var 
    // Calculate default props for use in custom themes
    _b = _a.appearance, 
    // Calculate default props for use in custom themes
    appearance = _b === void 0 ? 'default' : _b, _c = _a.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.isSelected, isSelected = _e === void 0 ? false : _e, _f = _a.shouldFitContainer, shouldFitContainer = _f === void 0 ? false : _f, _g = _a.spacing, spacing = _g === void 0 ? 'default' : _g, _h = _a.isLoading, isLoading = _h === void 0 ? false : _h, providedOnMouseEnter = _a.onMouseEnter, providedOnMouseLeave = _a.onMouseLeave, providedOnMouseDown = _a.onMouseDown, providedOnMouseUp = _a.onMouseUp, providedOnFocus = _a.onFocus, providedOnBlur = _a.onBlur, _j = _a.theme, theme = _j === void 0 ? defaultThemeFn : _j, rest = __rest(_a, ["appearance", "autoFocus", "isDisabled", "isSelected", "shouldFitContainer", "spacing", "isLoading", "onMouseEnter", "onMouseLeave", "onMouseDown", "onMouseUp", "onFocus", "onBlur", "theme"]);
    // TODO is there a nicer way to do this?
    // Add default props back into object for spreading
    var restProps = __assign({ appearance: appearance,
        autoFocus: autoFocus,
        isDisabled: isDisabled,
        isSelected: isSelected,
        shouldFitContainer: shouldFitContainer,
        spacing: spacing }, rest);
    var _k = __read(useState(initial), 2), state = _k[0], setState = _k[1];
    var onMouseEnter = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isHover: true })); });
        if (providedOnMouseEnter) {
            providedOnMouseEnter(event);
        }
    }, [providedOnMouseEnter]);
    var onMouseLeave = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isHover: false, isActive: false })); });
        if (providedOnMouseLeave) {
            providedOnMouseLeave(event);
        }
    }, [providedOnMouseLeave]);
    var onMouseDown = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isActive: true })); });
        if (providedOnMouseDown) {
            providedOnMouseDown(event);
        }
    }, [providedOnMouseDown]);
    var onMouseUp = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isActive: false })); });
        if (providedOnMouseUp) {
            providedOnMouseUp(event);
        }
    }, [providedOnMouseUp]);
    var onFocus = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isFocus: true })); });
        if (providedOnFocus) {
            providedOnFocus(event);
        }
    }, [providedOnFocus]);
    var onBlur = useCallback(function (event) {
        setState(function (current) { return (__assign(__assign({}, current), { isFocus: false })); });
        if (providedOnBlur) {
            providedOnBlur(event);
        }
    }, [providedOnBlur]);
    return (React.createElement(Theme.Provider, { value: theme },
        React.createElement(GlobalTheme.Consumer, null, function (_a) {
            var mode = _a.mode;
            return (React.createElement(Theme.Consumer, __assign({ mode: mode, state: getInteractionState(__assign(__assign({}, state), { isLoading: isLoading, isSelected: restProps.isSelected, isDisabled: restProps.isDisabled })), iconIsOnlyChild: getIsOnlySingleIcon(restProps), isLoading: isLoading }, restProps), function (_a) {
                var buttonStyles = _a.buttonStyles;
                return (React.createElement(ButtonBase, __assign({}, restProps, { ref: ref, overlay: isLoading ? React.createElement(LoadingSpinner, __assign({}, restProps)) : null, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseDown: onMouseDown, onMouseUp: onMouseUp, onFocus: onFocus, onBlur: onBlur, buttonCss: getSpecifiers(buttonStyles) })));
            }));
        })));
}));
// Tools including enzyme rely on components having a display name
CustomThemeButton.displayName = 'CustomThemeButton';
export default CustomThemeButton;
//# sourceMappingURL=custom-theme-button.js.map