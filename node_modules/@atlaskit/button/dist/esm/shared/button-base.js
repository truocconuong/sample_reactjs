import { __assign, __rest } from "tslib";
/** @jsx jsx */
import React, { useCallback, useEffect, useRef } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import { name as packageName, version as packageVersion, } from '../version.json';
import blockEvents from './block-events';
import { getContentStyle, getFadingCss, getIconStyle, overlayCss } from './css';
import useAutoFocus from './use-auto-focus';
function noop() { }
// Disabled buttons will still publish events for nested elements in webkit.
// We are disabling pointer events on child elements so that
// the button will always be the target of events
// Note: firefox does not have this behaviour for child elements
var noPointerEventsOnChildrenCss = {
    '> *': {
        pointerEvents: 'none',
    },
};
export default React.forwardRef(function ButtonBase(props, ref) {
    var _a = props.appearance, appearance = _a === void 0 ? 'default' : _a, buttonCss = props.buttonCss, _b = props.spacing, spacing = _b === void 0 ? 'default' : _b, _c = props.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = props.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = props.shouldFitContainer, shouldFitContainer = _e === void 0 ? false : _e, _f = props.isSelected, isSelected = _f === void 0 ? false : _f, iconBefore = props.iconBefore, iconAfter = props.iconAfter, children = props.children, className = props.className, href = props.href, overlay = props.overlay, _g = props.tabIndex, tabIndex = _g === void 0 ? 0 : _g, _h = props.type, type = _h === void 0 ? !href ? 'button' : undefined : _h, _j = props.onMouseDown, providedOnMouseDown = _j === void 0 ? noop : _j, _k = props.onClick, providedOnClick = _k === void 0 ? noop : _k, 
    // use the provided component prop,
    // else default to anchor if there is a href, and button if there is no href
    _l = props.component, 
    // use the provided component prop,
    // else default to anchor if there is a href, and button if there is no href
    Component = _l === void 0 ? href ? 'a' : 'button' : _l, testId = props.testId, 
    // I don't think this should be in button, but for now it is
    analyticsContext = props.analyticsContext, rest = __rest(props, ["appearance", "buttonCss", "spacing", "autoFocus", "isDisabled", "shouldFitContainer", "isSelected", "iconBefore", "iconAfter", "children", "className", "href", "overlay", "tabIndex", "type", "onMouseDown", "onClick", "component", "testId", "analyticsContext"]);
    var ourRef = useRef();
    var setRef = useCallback(function (node) {
        ourRef.current = node;
        if (ref == null) {
            return;
        }
        if (typeof ref === 'function') {
            ref(node);
            return;
        }
        // @ts-ignore
        ref.current = node;
    }, [ourRef, ref]);
    // Cross browser auto focusing is pretty broken, so we are doing it ourselves
    useAutoFocus(ourRef, autoFocus);
    var onClick = usePlatformLeafEventHandler({
        fn: providedOnClick,
        action: 'clicked',
        componentName: 'button',
        packageName: packageName,
        packageVersion: packageVersion,
        analyticsData: analyticsContext,
    });
    // Button currently calls preventDefault, which is not standard button behaviour
    var onMouseDown = useCallback(function (event) {
        event.preventDefault();
        providedOnMouseDown(event);
    }, [providedOnMouseDown]);
    // Lose focus when becoming disabled (standard button behaviour)
    useEffect(function () {
        var el = ourRef.current;
        if (isDisabled && el && el === document.activeElement) {
            el.blur();
        }
    }, [isDisabled]);
    // we are 'disabling' input with a button when there is an overlay
    var hasOverlay = Boolean(overlay);
    var fadeCss = getFadingCss({ hasOverlay: hasOverlay });
    var isInteractive = !isDisabled && !hasOverlay;
    return (jsx(Component, __assign({}, rest, { css: [buttonCss, isInteractive ? null : noPointerEventsOnChildrenCss], className: className, ref: setRef, onClick: onClick, onMouseDown: onMouseDown, disabled: isDisabled, href: isInteractive ? href : undefined, "data-has-overlay": hasOverlay ? true : undefined, "data-testid": testId, type: type, 
        // Adding a tab index so element is always focusable, even when not a <button> or <a>
        // Disabling focus via keyboard navigation when disabled
        // as this is standard button behaviour
        tabIndex: isDisabled ? -1 : tabIndex }, blockEvents({ isInteractive: isInteractive })),
        iconBefore ? (jsx("span", { css: [fadeCss, getIconStyle({ spacing: spacing })] }, iconBefore)) : null,
        children ? (jsx("span", { css: [fadeCss, getContentStyle({ spacing: spacing })] }, children)) : null,
        iconAfter ? (jsx("span", { css: [fadeCss, getIconStyle({ spacing: spacing })] }, iconAfter)) : null,
        overlay ? jsx("span", { css: overlayCss }, overlay) : null));
});
//# sourceMappingURL=button-base.js.map