"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/** @jsx jsx */
var react_1 = tslib_1.__importStar(require("react"));
var core_1 = require("@emotion/core");
var analytics_next_1 = require("@atlaskit/analytics-next");
var version_json_1 = require("../version.json");
var block_events_1 = tslib_1.__importDefault(require("./block-events"));
var css_1 = require("./css");
var use_auto_focus_1 = tslib_1.__importDefault(require("./use-auto-focus"));
function noop() { }
// Disabled buttons will still publish events for nested elements in webkit.
// We are disabling pointer events on child elements so that
// the button will always be the target of events
// Note: firefox does not have this behaviour for child elements
var noPointerEventsOnChildrenCss = {
    '> *': {
        pointerEvents: 'none',
    },
};
exports.default = react_1.default.forwardRef(function ButtonBase(props, ref) {
    var _a = props.appearance, appearance = _a === void 0 ? 'default' : _a, buttonCss = props.buttonCss, _b = props.spacing, spacing = _b === void 0 ? 'default' : _b, _c = props.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = props.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = props.shouldFitContainer, shouldFitContainer = _e === void 0 ? false : _e, _f = props.isSelected, isSelected = _f === void 0 ? false : _f, iconBefore = props.iconBefore, iconAfter = props.iconAfter, children = props.children, className = props.className, href = props.href, overlay = props.overlay, _g = props.tabIndex, tabIndex = _g === void 0 ? 0 : _g, _h = props.type, type = _h === void 0 ? !href ? 'button' : undefined : _h, _j = props.onMouseDown, providedOnMouseDown = _j === void 0 ? noop : _j, _k = props.onClick, providedOnClick = _k === void 0 ? noop : _k, 
    // use the provided component prop,
    // else default to anchor if there is a href, and button if there is no href
    _l = props.component, 
    // use the provided component prop,
    // else default to anchor if there is a href, and button if there is no href
    Component = _l === void 0 ? href ? 'a' : 'button' : _l, testId = props.testId, 
    // I don't think this should be in button, but for now it is
    analyticsContext = props.analyticsContext, rest = tslib_1.__rest(props, ["appearance", "buttonCss", "spacing", "autoFocus", "isDisabled", "shouldFitContainer", "isSelected", "iconBefore", "iconAfter", "children", "className", "href", "overlay", "tabIndex", "type", "onMouseDown", "onClick", "component", "testId", "analyticsContext"]);
    var ourRef = react_1.useRef();
    var setRef = react_1.useCallback(function (node) {
        ourRef.current = node;
        if (ref == null) {
            return;
        }
        if (typeof ref === 'function') {
            ref(node);
            return;
        }
        // @ts-ignore
        ref.current = node;
    }, [ourRef, ref]);
    // Cross browser auto focusing is pretty broken, so we are doing it ourselves
    use_auto_focus_1.default(ourRef, autoFocus);
    var onClick = analytics_next_1.usePlatformLeafEventHandler({
        fn: providedOnClick,
        action: 'clicked',
        componentName: 'button',
        packageName: version_json_1.name,
        packageVersion: version_json_1.version,
        analyticsData: analyticsContext,
    });
    // Button currently calls preventDefault, which is not standard button behaviour
    var onMouseDown = react_1.useCallback(function (event) {
        event.preventDefault();
        providedOnMouseDown(event);
    }, [providedOnMouseDown]);
    // Lose focus when becoming disabled (standard button behaviour)
    react_1.useEffect(function () {
        var el = ourRef.current;
        if (isDisabled && el && el === document.activeElement) {
            el.blur();
        }
    }, [isDisabled]);
    // we are 'disabling' input with a button when there is an overlay
    var hasOverlay = Boolean(overlay);
    var fadeCss = css_1.getFadingCss({ hasOverlay: hasOverlay });
    var isInteractive = !isDisabled && !hasOverlay;
    return (core_1.jsx(Component, tslib_1.__assign({}, rest, { css: [buttonCss, isInteractive ? null : noPointerEventsOnChildrenCss], className: className, ref: setRef, onClick: onClick, onMouseDown: onMouseDown, disabled: isDisabled, href: isInteractive ? href : undefined, "data-has-overlay": hasOverlay ? true : undefined, "data-testid": testId, type: type, 
        // Adding a tab index so element is always focusable, even when not a <button> or <a>
        // Disabling focus via keyboard navigation when disabled
        // as this is standard button behaviour
        tabIndex: isDisabled ? -1 : tabIndex }, block_events_1.default({ isInteractive: isInteractive })),
        iconBefore ? (core_1.jsx("span", { css: [fadeCss, css_1.getIconStyle({ spacing: spacing })] }, iconBefore)) : null,
        children ? (core_1.jsx("span", { css: [fadeCss, css_1.getContentStyle({ spacing: spacing })] }, children)) : null,
        iconAfter ? (core_1.jsx("span", { css: [fadeCss, css_1.getIconStyle({ spacing: spacing })] }, iconAfter)) : null,
        overlay ? core_1.jsx("span", { css: css_1.overlayCss }, overlay) : null));
});
//# sourceMappingURL=button-base.js.map