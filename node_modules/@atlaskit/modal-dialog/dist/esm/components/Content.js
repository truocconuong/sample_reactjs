import { __assign, __extends } from "tslib";
/** @jsx jsx */
import React from 'react';
import { jsx } from '@emotion/core';
import rafSchedule from 'raf-schd';
import ScrollLock, { TouchScrollable } from 'react-scrolllock';
import { bodyStyles, Body as DefaultBody, keylineHeight, wrapperStyles, } from '../styled/Content';
import Footer from './Footer';
import Header from './Header';
function getInitialState() {
    return {
        showFooterKeyline: false,
        showHeaderKeyline: false,
        showContentFocus: false,
        tabbableElements: [],
    };
}
function mergeRefs(refs) {
    return function (value) {
        refs.forEach(function (ref) {
            if (typeof ref === 'function') {
                ref(value);
            }
            else if (ref != null) {
                ref.current = value;
            }
        });
    };
}
var Content = /** @class */ (function (_super) {
    __extends(Content, _super);
    function Content() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.escapeIsHeldDown = false;
        _this._isMounted = false;
        _this.scrollContainer = null;
        _this.state = getInitialState();
        _this.determineKeylines = rafSchedule(function () {
            if (!_this.scrollContainer) {
                return;
            }
            var _a = _this.scrollContainer, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
            var scrollableDistance = scrollHeight - clientHeight;
            var showHeaderKeyline = scrollTop > keylineHeight;
            var showFooterKeyline = scrollTop <= scrollableDistance - keylineHeight;
            var showContentFocus = scrollHeight > clientHeight;
            _this.setState({
                showHeaderKeyline: showHeaderKeyline,
                showFooterKeyline: showFooterKeyline,
                showContentFocus: showContentFocus,
            });
        });
        _this.getScrollContainer = function (ref) {
            if (!ref) {
                return;
            }
            _this.scrollContainer = ref;
        };
        _this.handleKeyUp = function () {
            _this.escapeIsHeldDown = false;
        };
        _this.handleKeyDown = function (event) {
            var _a = _this.props, onClose = _a.onClose, shouldCloseOnEscapePress = _a.shouldCloseOnEscapePress, _b = _a.stackIndex, stackIndex = _b === void 0 ? 0 : _b;
            var isEscapeKeyPressed = event.key === 'Escape';
            // avoid consumers accidentally closing multiple modals if they hold escape.
            if (_this.escapeIsHeldDown) {
                return;
            }
            if (isEscapeKeyPressed) {
                _this.escapeIsHeldDown = true;
            }
            // only the foremost modal should be interactive.
            if (!_this._isMounted || stackIndex > 0) {
                return;
            }
            if (isEscapeKeyPressed && shouldCloseOnEscapePress) {
                onClose(event);
            }
        };
        _this.handleStackChange = function (stackIndex) {
            var onStackChange = _this.props.onStackChange;
            if (onStackChange) {
                onStackChange(stackIndex);
            }
        };
        return _this;
    }
    Content.prototype.componentDidMount = function () {
        this._isMounted = true;
        document.addEventListener('keydown', this.handleKeyDown, false);
        document.addEventListener('keyup', this.handleKeyUp, false);
        if (this.scrollContainer) {
            var capturedScrollContainer = this.scrollContainer;
            window.addEventListener('resize', this.determineKeylines, false);
            capturedScrollContainer.addEventListener('scroll', this.determineKeylines, false);
            this.determineKeylines();
        }
        /* eslint-disable no-console */
        // Check for deprecated props
        if (this.props.header) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the header prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        if (this.props.footer) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the footer prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        if (this.props.body) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the body prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        // Check that custom body components have used ForwardRef to attach to a DOM element
        if (this.props.components.Body) {
            if (!(this.scrollContainer instanceof HTMLElement)) {
                console.warn('@atlaskit/modal-dialog: Warning - Ref must attach to a DOM element; check you are using forwardRef and attaching the ref to an appropriate element. Check the examples for more details.');
            }
        }
        /* eslint-enable no-console */
    };
    Content.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        var stackIndex = this.props.stackIndex;
        // update focus scope and let consumer know when stack index has changed
        if (nextProps.stackIndex && nextProps.stackIndex !== stackIndex) {
            this.handleStackChange(nextProps.stackIndex);
        }
    };
    Content.prototype.componentWillUnmount = function () {
        this._isMounted = false;
        document.removeEventListener('keydown', this.handleKeyDown, false);
        document.removeEventListener('keyup', this.handleKeyUp, false);
        if (this.scrollContainer) {
            var capturedScrollContainer = this.scrollContainer;
            window.removeEventListener('resize', this.determineKeylines, false);
            capturedScrollContainer.removeEventListener('scroll', this.determineKeylines, false);
        }
    };
    Content.prototype.render = function () {
        var _this = this;
        var _a = this.props, actions = _a.actions, appearance = _a.appearance, DeprecatedBody = _a.body, children = _a.children, components = _a.components, footer = _a.footer, header = _a.header, heading = _a.heading, isChromeless = _a.isChromeless, isHeadingMultiline = _a.isHeadingMultiline, onClose = _a.onClose, shouldScroll = _a.shouldScroll, testId = _a.testId, headingId = _a.headingId;
        var _b = this.state, showFooterKeyline = _b.showFooterKeyline, showHeaderKeyline = _b.showHeaderKeyline, showContentFocus = _b.showContentFocus;
        var _c = components.Container, Container = _c === void 0 ? 'div' : _c, CustomBody = components.Body;
        var Body = CustomBody || DeprecatedBody || DefaultBody;
        return (jsx(Container, { css: wrapperStyles, "data-testid": testId },
            isChromeless ? (children) : (jsx(React.Fragment, null,
                jsx(Header, { id: headingId, appearance: appearance, component: components.Header ? components.Header : header, heading: heading, onClose: onClose, isHeadingMultiline: isHeadingMultiline, showKeyline: showHeaderKeyline, testId: testId }),
                this.scrollContainer instanceof HTMLElement ? (jsx(TouchScrollable, null, function (touchRef) { return (jsx(Body, __assign({ tabIndex: showContentFocus ? 0 : undefined, css: bodyStyles(shouldScroll) }, (!Body.hasOwnProperty('styledComponentId')
                    ? {
                        ref: mergeRefs([touchRef, _this.getScrollContainer]),
                    }
                    : {
                        innerRef: mergeRefs([
                            touchRef,
                            _this.getScrollContainer,
                        ]),
                    })), children)); })) : (jsx(Body, __assign({ tabIndex: showContentFocus ? 0 : undefined, css: bodyStyles(shouldScroll) }, (!Body.hasOwnProperty('styledComponentId')
                    ? {
                        ref: this.getScrollContainer,
                    }
                    : {
                        innerRef: this.getScrollContainer,
                    })), children)),
                jsx(Footer, { actions: actions, appearance: appearance, component: components.Footer ? components.Footer : footer, onClose: onClose, showKeyline: showFooterKeyline }))),
            jsx(ScrollLock, null)));
    };
    Content.defaultProps = {
        autoFocus: false,
        components: {},
        isChromeless: false,
        stackIndex: 0,
        isHeadingMultiline: true,
    };
    return Content;
}(React.Component));
export default Content;
//# sourceMappingURL=Content.js.map