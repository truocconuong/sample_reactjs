/** @jsx jsx */
import React from 'react';
import { jsx } from '@emotion/core';
import rafSchedule from 'raf-schd';
import ScrollLock, { TouchScrollable } from 'react-scrolllock';
import { bodyStyles, Body as DefaultBody, keylineHeight, wrapperStyles, } from '../styled/Content';
import Footer from './Footer';
import Header from './Header';
function getInitialState() {
    return {
        showFooterKeyline: false,
        showHeaderKeyline: false,
        showContentFocus: false,
        tabbableElements: [],
    };
}
function mergeRefs(refs) {
    return (value) => {
        refs.forEach((ref) => {
            if (typeof ref === 'function') {
                ref(value);
            }
            else if (ref != null) {
                ref.current = value;
            }
        });
    };
}
export default class Content extends React.Component {
    constructor() {
        super(...arguments);
        this.escapeIsHeldDown = false;
        this._isMounted = false;
        this.scrollContainer = null;
        this.state = getInitialState();
        this.determineKeylines = rafSchedule(() => {
            if (!this.scrollContainer) {
                return;
            }
            const { scrollTop, scrollHeight, clientHeight } = this.scrollContainer;
            const scrollableDistance = scrollHeight - clientHeight;
            const showHeaderKeyline = scrollTop > keylineHeight;
            const showFooterKeyline = scrollTop <= scrollableDistance - keylineHeight;
            const showContentFocus = scrollHeight > clientHeight;
            this.setState({
                showHeaderKeyline,
                showFooterKeyline,
                showContentFocus,
            });
        });
        this.getScrollContainer = (ref) => {
            if (!ref) {
                return;
            }
            this.scrollContainer = ref;
        };
        this.handleKeyUp = () => {
            this.escapeIsHeldDown = false;
        };
        this.handleKeyDown = (event) => {
            const { onClose, shouldCloseOnEscapePress, stackIndex = 0 } = this.props;
            const isEscapeKeyPressed = event.key === 'Escape';
            // avoid consumers accidentally closing multiple modals if they hold escape.
            if (this.escapeIsHeldDown) {
                return;
            }
            if (isEscapeKeyPressed) {
                this.escapeIsHeldDown = true;
            }
            // only the foremost modal should be interactive.
            if (!this._isMounted || stackIndex > 0) {
                return;
            }
            if (isEscapeKeyPressed && shouldCloseOnEscapePress) {
                onClose(event);
            }
        };
        this.handleStackChange = (stackIndex) => {
            const { onStackChange } = this.props;
            if (onStackChange) {
                onStackChange(stackIndex);
            }
        };
    }
    componentDidMount() {
        this._isMounted = true;
        document.addEventListener('keydown', this.handleKeyDown, false);
        document.addEventListener('keyup', this.handleKeyUp, false);
        if (this.scrollContainer) {
            const capturedScrollContainer = this.scrollContainer;
            window.addEventListener('resize', this.determineKeylines, false);
            capturedScrollContainer.addEventListener('scroll', this.determineKeylines, false);
            this.determineKeylines();
        }
        /* eslint-disable no-console */
        // Check for deprecated props
        if (this.props.header) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the header prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        if (this.props.footer) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the footer prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        if (this.props.body) {
            console.warn("@atlaskit/modal-dialog: Deprecation warning - Use of the body prop in ModalDialog is deprecated. Please compose your ModalDialog using the 'components' prop instead");
        }
        // Check that custom body components have used ForwardRef to attach to a DOM element
        if (this.props.components.Body) {
            if (!(this.scrollContainer instanceof HTMLElement)) {
                console.warn('@atlaskit/modal-dialog: Warning - Ref must attach to a DOM element; check you are using forwardRef and attaching the ref to an appropriate element. Check the examples for more details.');
            }
        }
        /* eslint-enable no-console */
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        const { stackIndex } = this.props;
        // update focus scope and let consumer know when stack index has changed
        if (nextProps.stackIndex && nextProps.stackIndex !== stackIndex) {
            this.handleStackChange(nextProps.stackIndex);
        }
    }
    componentWillUnmount() {
        this._isMounted = false;
        document.removeEventListener('keydown', this.handleKeyDown, false);
        document.removeEventListener('keyup', this.handleKeyUp, false);
        if (this.scrollContainer) {
            const capturedScrollContainer = this.scrollContainer;
            window.removeEventListener('resize', this.determineKeylines, false);
            capturedScrollContainer.removeEventListener('scroll', this.determineKeylines, false);
        }
    }
    render() {
        const { actions, appearance, body: DeprecatedBody, children, components, footer, header, heading, isChromeless, isHeadingMultiline, onClose, shouldScroll, testId, headingId, } = this.props;
        const { showFooterKeyline, showHeaderKeyline, showContentFocus, } = this.state;
        const { Container = 'div', Body: CustomBody } = components;
        const Body = CustomBody || DeprecatedBody || DefaultBody;
        return (jsx(Container, { css: wrapperStyles, "data-testid": testId },
            isChromeless ? (children) : (jsx(React.Fragment, null,
                jsx(Header, { id: headingId, appearance: appearance, component: components.Header ? components.Header : header, heading: heading, onClose: onClose, isHeadingMultiline: isHeadingMultiline, showKeyline: showHeaderKeyline, testId: testId }),
                this.scrollContainer instanceof HTMLElement ? (jsx(TouchScrollable, null, (touchRef) => (jsx(Body, Object.assign({ tabIndex: showContentFocus ? 0 : undefined, css: bodyStyles(shouldScroll) }, (!Body.hasOwnProperty('styledComponentId')
                    ? {
                        ref: mergeRefs([touchRef, this.getScrollContainer]),
                    }
                    : {
                        innerRef: mergeRefs([
                            touchRef,
                            this.getScrollContainer,
                        ]),
                    })), children)))) : (jsx(Body, Object.assign({ tabIndex: showContentFocus ? 0 : undefined, css: bodyStyles(shouldScroll) }, (!Body.hasOwnProperty('styledComponentId')
                    ? {
                        ref: this.getScrollContainer,
                    }
                    : {
                        innerRef: this.getScrollContainer,
                    })), children)),
                jsx(Footer, { actions: actions, appearance: appearance, component: components.Footer ? components.Footer : footer, onClose: onClose, showKeyline: showFooterKeyline }))),
            jsx(ScrollLock, null)));
    }
}
Content.defaultProps = {
    autoFocus: false,
    components: {},
    isChromeless: false,
    stackIndex: 0,
    isHeadingMultiline: true,
};
//# sourceMappingURL=Content.js.map